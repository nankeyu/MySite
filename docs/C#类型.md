[TOC]

------------

## 1. 值类型和引用类型

C#中的类型分为值类型(Value Type)和引用类型(Reference Type)。这是以它们在计算机内存中的分配方式来划分的。

**值类型包括结构和枚举，引用类型包括类、接口、委托等。**还有一种特殊的值类型，称为简单类型(Simple Type)，比如byte，int等，简单类型实际是BCL基类库类型的别名。

比如：声明一个int类型，实际上是声明一个**System.Int32结构类型**。在Int32类型中定义的方法和属性都可以在int类型上调用。

------------


### 1.1 值类型

所有值类型都隐式地继承自System.ValueType类型。在C#代码中看不到这个继承关系，只有通过MSIL代码可以看到。System.ValueType类型和所有的引用类型都继承自System.Object基类。

C#不支持多重继承，因为结构已经隐式地继承自ValueType，所以结构不支持继承。

> 栈(stack)是一种后进先出的数据结构，在内存中，变量会被分配在栈上来进行操作。堆(heap)是用来为引用类型的实例(对象)分配空间的内存区域，在堆上创建一个对象，会将对象的地址传给栈上的变量(反过来叫变量指向此对象，或者变量引用此对象)。

------------

声明一个值类型的变量(Variable)时，变量本身包含了值类型的全部字段，该变量会被分配在线程堆栈(Thread Stack)上。

假如有一个值类型，代表直线上的一点：
```csharp
    public struct ValPoint
    {
        public int x;
        public ValPoint(int x)
        {
            this.x = x;
        }
    }
```
在程序中写下变量的声明语句时：
```csharp
ValPoint vPoint1;
```
实际产生的效果是声明了vPoint1变量，变量本身就包含了值类型的所有字段。

![](images/7874828.png)

观察MSIL代码，会发现此时变量还没有被压到栈上，因为.maxstack为0；并且没有看到入栈的指令，只有对变量进行操作，才会进行入栈。

![](images/7684953.png)

因为变量已经包含了值类型的所有字段，此时已经可以对它进行操作了，对变量的操作实际是一系列的入栈，出栈操作。

```csharp
vPoint1.x = 10;
Console.WriteLine(vPoint1.x);
```
> 如果将ValPoint改为引用类型(比如class)，会出现编译错误：使用了未赋值的局部变量"vPoint1"。引用类型在运行时经常会抛出NullReferenceException异常。因为vPoint是一个值类型，不存在引用，所以永远不会抛出此异常。

如果不对`vPoint1.x`进行赋值，直接进行打印操作，会出现编译错误：使用了可能未赋值的字段"x"。因为在.NET中，所有的元素使用前都必须初始化。

虽然vPoint1变量本身不需要像类一样使用new操作符创建一个实例(结构类型变量本身就相当于一个实例)，但如果要使用它的内部成员(x)，则要在使用前对它进行赋值。结构还有一个特性：**调用结构上的方法前，需要对其所有的字段进行赋值**。

这样会产生一个问题：没有用到x字段，但为了调用方法，还要专门为x字段进行赋值。解决这个问题可以通过这样的方式：编译器隐式地为结构类型创建无参数的构造函数。在这个构造函数中会对结构成员进行初始化，所有的值类型成员被赋予0或相当于0的值，所有的引用类型被赋予null值。(因此，Struct类型不可以自行声明无参数的构造函数)。所以，可以通过隐式声明的构造函数去创建一个ValPoint类型变量：
```csharp
ValPoint vPoint1 = new ValPoint();
```

- "="的左边在线程栈上创建一个ValPoint类型的变量vPoint1，结构的所有成员均未赋值。在进行`new ValPoint()`之前，将vPoint1压到栈上。

- "="的右边，new操作符并不分配内存，也不是创建实例。它仅仅是调用了 ValPoint结构的默认构造函数，根据构造函数去初始化vPoint1结构的所有字段。

------------

如果不声明变量，像下面这样编写代码：
```csharp
Console.WriteLine((new ValPoint()).x);
```
这种情况会创建一个临时变量，然后使用结构的默认构造函数对临时变量进行初始化。

------------

### 1.2 引用类型

当声明一个引用类型变量，并使用new操作符创建引用类型实例的时候，该引用类型的变量会被分配到线程栈上，变量保存了位于堆上的引用类型的实例的内存地址。变量本身不包含任何类型所定义的数据。如果仅仅声明一个变量，但不使用new操作符，由于在堆上还没有创建类型的实例，变量值为null，意思是不指向任何对象(堆上的对象的实例)。对于变量的类型声明用于限制此变量可以保存的类型实例的地址。

> 概念讲解：变量(Variable)可以是一个值类型，也可以是一个引用类型。当变量是引用类型时，由于本身只包含实际对象的引用(内存地址)，因此也叫作对象引用。而在堆上创建的对象(Object)，称为对象的实例(Instance，根据类的定义分配了内存)。


------------

如果有这样一个类，依然代表直线上的一点：
```csharp
    public class RefPoint
    {
        public int x;
        public RefPoint(int x){this.x = x;}
        public RefPoint() { }
    }
```
仅仅写下声明语句时：
```csharp
RefPoint rPoint1;
```
在线程栈上创建一个不包含任何数据，也不指向任何对象(不包含内存地址)的变量。

当使用new操作符时：
```csharp
RefPoint rPoint1 = new RefPoint(1);
```
会完成以下几件事：
- 在应用程序堆(Heap)上创建一个引用类型(ReferenceType)对象的实例，并为它分配内存地址。
- 自动传递该实例的引用给构造函数(因此可以在构造函数中使用this来访问这个实例)。
- 调用该类型的构造函数。
- 返回该实例的引用(内存地址)，复制给rPoint1变量。


------------

### 1.3 装箱和拆箱
简单说，装箱就是将一个值类型转换成等价的引用类型。过程如下：
1. 在堆上为新生成的对象实例分配内存。该对象实例包含数据，但它没有名称。
2. 将栈上值类型变量的值复制到堆上的对象中。
3. 将堆上创建的对象的地址返回给引用类型变量。

------------

而拆箱是将一个已装箱的引用类型转换为值类型。拆箱操作需要显式声明拆箱后转换的类型，分为两步：
1. 获取已装箱的对象的地址。
2. 将值从堆上的对象中复制到堆栈上的值变量中。

装箱和拆箱需要反复在堆上进行操作，在程序中应避免无意义的装箱和拆箱。

------------
## 2. 对象判等
对象复制(克隆)的一个前提条件是：要能够知道复制前后的两个对象是否相等。
### 2.1 引用类型判等

在`System.Object`基类型中，定义了实例方法`Equals(Object objA,Object objB)`，静态方法`Equals(Object objA,Object objB)`，静态方法`ReferenceEquals(Object objA,Object objB)`这三个方法进行对象的判等。

```csharp
    public virtual bool Equals(Object obj)
    {
        return RuntimeHelpers.Equals(this, obj);
    }

    public static bool Equals(Object objA, Object objB) 
    {
        if (objA==objB) {
            return true;
        }
        if (objA==null || objB==null) {
            return false;
        }
        return objA.Equals(objB);
    }

    public static bool ReferenceEquals (Object objA, Object objB) {
        return objA == objB;
    }
```

`ReferenceEquals(Object objA,Object objB)`方法简单地返回`objA==objB`，判等两个变量是否指向堆上同一个对象。对于`Object.Equals()`静态方法，如果任何一个对象引用为null，则总是返回false。当对象不为null时，最后调用了实例上的Equals()方法。


------------

### 2.2 简单值类型判等
值类型都会隐式地继承自`System.ValueType`类型，而ValueType类型覆盖了基类System.Object类型的Equals()方法。

------------

## 3. 对象复制
有时候创建一个对象可能会非常耗时，比如对象需要从远程数据库中获取数据来填充，或者创建对象需要读取硬盘文件。此时如果已经有了一个对象，再创建新对象时，可能会采用复制现有对象的方法，而不是重新建一个新的对象。

### 3.1 浅度复制

浅度复制和深度复制是以如何复制对象的成员来区分的。对象的成员有可能是值类型，有可能是引用类型。对对象进行浅度复制时，对于值类型成员，会复制其本身(值类型变量本身包含了所有数据，复制时按位复制)；对于引用类型成员，仅仅复制引用，而不在堆上重新创建对象。结果就是新对象的引用成员和复制对象的引用成员指向同一个对象。

当复制一个结构类型成员时，直接创建一个新的结构类型变量，然后对它赋值，就相当于进行了浅度复制，也可以认为结构类型隐式地实现了浅度复制。

对于引用类型，在.NET Framework中，有一个ICloneable接口，可以实现这个接口进行浅度复制(也可以是深度复制)。这个接口只要求实现一个方法Clone()，它返回当前对象的副本，并不需要自己实现这个方法，在System.Object基类中，有一个保护的MemberwiseClone()方法，用于进行浅度复制。


------------

### 3.2 深度复制

深度复制就是将引用成员指向的对象也进行复制。实际的过程是创建新的引用成员指向的对象，然后复制对象中所包含的数据。

深度复制可能会变得非常复杂，因为引用成员指向的对象可能包含另一个引用类型成员。如果每个对象都要去进行深度复制就太麻烦，可以利用序列化/反序列化来对对象进行深度复制：先把对象序列化(Serialize)到内存中，然后再进行反序列化。

```csharp
public object Clone()
{
    BinaryFormatter bf = new BinaryFormatter();
    MemoryStream ms = new MemoryStream();
    bf.Serialize(ms, this);
    ms.Position = 0;
    return (bf.Deserialize(ms));
}
```

> 注意：如果想将对象进行序列化，对象本身，及其所有的自定义成员(类、结构)，都必须使用Serializable特性进行标记。


------------







